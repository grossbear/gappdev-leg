//////////////////////////////////////////////////////////////////////////////
//
//  File:       MathPrim.inl
//  Content:    Standart math inline functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __MATHFUNC_INL__
#define __MATHFUNC_INL__

///////////////////////////////////////////////////////////////////////////////////////
// Absolute Value Functions
///////////////////////////////////////////////////////////////////////////////////////
template <class Ttype>
M_INLINE Ttype  mabs(Ttype i)
{
    return (i >> (sizeof(Ttype)-1)) ? ((~i)+1) : (i);
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float  mabs(float f)
{
    return *(float*)&(*(int32t*)&f &= M_INT_MAX);
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double mabs(double d)
{
    return *(double*)&(*(int64t*)&d &= M_INT64_MAX);
}

///////////////////////////////////////////////////////////////////////////////////////
// Negate Values
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float  mnegate(float f)
{
    return *(float*)&(*(int32t*)&f ^= M_INT_MIN);
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double mnegate(double d)
{
    return *(double*)&(*(int64t*)&d ^= M_INT64_MIN);
}


///////////////////////////////////////////////////////////////////////////////////////
M_INLINE boolt  mnear0(float f)
{
    return mabs(f) < FLOAT_EPS;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE boolt  mnear0(double d)
{
    return mabs(d) < DOUBLE_EPS;
}

///////////////////////////////////////////////////////////////////////////////////////
// Check If Value Is Greater Than 0
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE int32t mgre0(float f)
{
    return *(int32t*)&f > 0;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE int64t mgre0(double d)
{
    return *(int64t*)&d > 0;
}

///////////////////////////////////////////////////////////////////////////////////////
// Check If Value Is Greater Or Equals Zero
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE int32t mgreq0(float f)
{
    return *(int32t*)&f <= 0x80000000UL;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE int64t mgreq0(double d)
{
    return *(int64t*)&d <= 0x8000000000000000UL;
}

///////////////////////////////////////////////////////////////////////////////////////
// Check If Value Equals Zero
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE boolt mis0(float f)
{
    return (*(int32t*)&f & M_INT_MAX) == 0;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE boolt mis0(double d)
{
    return (*(int64t*)&d & M_INT64_MAX) == 0;
}

///////////////////////////////////////////////////////////////////////////////////////
// Check If Value Is Less Or Equals Zero
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE int32t mlesseq0(float f)
{
    return *(int32t*)&f <= 0;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE int64t mlesseq0(double d)
{
    return *(int64t*)&d <= 0;
}

///////////////////////////////////////////////////////////////////////////////////////
// Check If Value Is Less Than 0
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE int32t mless0(float f)
{
    return *(int32t*)&f < 0;
    //return *(int32t*)&f > 0x80000000UL;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE int64t mless0(double d)
{
    return *(int64t*)&d < 0;
    //return *(int64t*)&d > 0x8000000000000000UL;
}
///////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////
// Clamp Float Value To 0
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float mclamp0(float f)
{
    int32t s = (*(int32t*)&f) >> 31;
    s = ~s;
    *(int32t*)&f &= s;

    return f;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double mclamp0(double d)
{
    int64t s = (*(int64t*)&d) >> 63;
    s = ~s;
    *(int64t*)&d &= s;

    return d;
}

///////////////////////////////////////////////////////////////////////////////////////
// Clamp Float Value To 1
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float mclamp1(float f)
{
    return *(int32t*)&f > 0x3f800000 ? 1.0f : f;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double mclamp1(double d)
{
    return *(int64t*)&d > 0x3ff0000000000000 ? 1.0 : d;
}

///////////////////////////////////////////////////////////////////////////////////////
// Clamp Float Value To [0,1]
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float mclamp01(float f)
{
    if(mless0(f))
        return 0.0f;

    return mclamp1(f);
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double mclamp01(double d)
{
    if(mless0(d))
        return 0.0;

    return mclamp1(d);
}


///////////////////////////////////////////////////////////////////////////////////////
// Function Template Clamping Value
///////////////////////////////////////////////////////////////////////////////////////
template <class Ttype>
M_INLINE Ttype  mclamp(const Ttype &min, const Ttype &max, const Ttype &val)
{
    return (val < min) ? (min) : ((val > max) ? max : val);
}



///////////////////////////////////////////////////////////////////////////////////////
// Check If Number Is Power Of 2
///////////////////////////////////////////////////////////////////////////////////////
template <class Ttype>
M_INLINE boolt mispow2(Ttype n)
{
    return !(n & (n - 1));
}

///////////////////////////////////////////////////////////////////////////////////////
// Packing Values From [-1,1] To [0,1] 
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float mpack01(float x)
{
    return x*0.5f + 0.5f;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double mpack01(double x)
{
    return x*0.5 + 0.5;
}

///////////////////////////////////////////////////////////////////////////////////////
// Unpacking Values From [0,1] To [-1,1]
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float munpack01(float x)
{
    return x*2.0f - 1.0f;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double munpack01(double x)
{
    return x*2.0 - 1.0;
}

///////////////////////////////////////////////////////////////////////////////////////
// Coverting Degrees To Radians
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float mtorad(float deg)
{
    return deg*MDEG2RAD;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double mtorad(double deg)
{
    return deg*DEG2RAD;
}

///////////////////////////////////////////////////////////////////////////////////////
// Coverting Radians To Degrees
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float mtodeg(float rad)
{
    return rad*MRAD2DEG;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double mtodeg(double rad)
{
    return rad*RAD2DEG;
}


///////////////////////////////////////////////////////////////////////////////////////
// Set To Zero If Value Is Near 
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float   malign0(float x)
{
    if((x > -FLOAT_EPS) && (x < FLOAT_EPS))
        return 0.0f;
    else
        return x;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double  malign0(double x)
{
    if((x > -DOUBLE_EPS) && (x < DOUBLE_EPS))
        return 0.0;
    else
        return x;
}

///////////////////////////////////////////////////////////////////////////////////////
// Set To One If Value Is Nearly One
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float   malign1(float x)
{
    if( (x > (1.0f-FLOAT_EPS)) && (x < (1.0f+FLOAT_EPS)) )
        return 1.0f;
    else
        return x;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double  malign1(double x)
{
    if( (x > (1.0-DOUBLE_EPS)) && (x < (1.0+DOUBLE_EPS)) )
        return 1.0;
    else
        return x;
}

///////////////////////////////////////////////////////////////////////////////////////
// Calculates The Floor Of A Value x
///////////////////////////////////////////////////////////////////////////////////////

M_FORCE float   mfloor(float x)
{
    return floorf(x);
}
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE double  mfloor(double x)
{
    return floor(x);
}
///////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////
// Calculates The Ceiling Of A Value x
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE float   mceil(float x)
{
    return ceilf(x);
}
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE double  mceil(double x)
{
    return ceil(x);
}


///////////////////////////////////////////////////////////////////////////////////////
// Getting Maximum Value 
///////////////////////////////////////////////////////////////////////////////////////
template <class Ttype>
Ttype   mmax(Ttype x, Ttype y)
{
    return (x > y) ? (x) : (y);
}   
///////////////////////////////////////////////////////////////////////////////////////
// Getting Minimum Value 
///////////////////////////////////////////////////////////////////////////////////////
template <class Ttype>
Ttype   mmin(Ttype x, Ttype y)
{
    return (x < y) ? (x) : (y);
}

///////////////////////////////////////////////////////////////////////////////////////
// Sgn
///////////////////////////////////////////////////////////////////////////////////////
template <class Ttype>
M_INLINE Ttype msgn(Ttype x)
{
    return (x > 0) ? (1) : ((x < 0) ? (-1) : (0));
}

///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float msgn(float x)
{
    if (mless0(x))
        return -1.0f;
    else if (mgre0(x))
        return 1.0f;
    else
        return 0.0f;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double msgn(double x)
{
    if (mless0(x))
        return -1.0;
    else if (mgre0(x))
        return 1.0;
    else
        return 0.0;
}
///////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////
// Natural Logarithm (Base e) Of x
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float   mln(float x)
{
    return logf(x);
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double  mln(double x)
{
    return log(x);
}
///////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////
// Logarithm Base 10 Of X
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE float   mlog10(float x)
{
    return log10f(x);
}
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE double  mlog10(double x)
{
    return log10(x);
}
///////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////
// Exponent
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE float   mexp(float x)
{
    return expf(x);
}
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE double  mexp(double x)
{
    return exp(x);
}
///////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////
// Calculate x Raised To The Power y
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE float   mpow(float x, float y)
{
    return powf(x,y);
}
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE double  mpow(double x, double y)
{
    return pow(x,y);
}
///////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////
// Inverting Number 
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE float   minvert(float x)
{
    ASSERT(!mnear0(x));
    return 1.0f/x;
}
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE double  minvert(double x)
{
    ASSERT(!mnear0(x));
    return 1.0/x;
}


///////////////////////////////////////////////////////////////////////////////////////
// Splits A Floating-Point Value Into Fractional And Integer Parts
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE float   mmodf(float x, float *y)
{
    return modff(x,y);
}
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE double  mmodf(double x, double *y)
{
    return modf(x,y);
}
///////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////
// Calculates The Floating-Point Remainder
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE float   mfmod(float x, float y)
{
    return fmodf(x,y);
}
///////////////////////////////////////////////////////////////////////////////////////
M_FORCE double  mfmodf(double x, double y)
{
    return fmod(x,y);
}
///////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////
// Float Const Multiplication Functions
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float   mmultpi(float x)
{
    return x*M_PI;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float   mmult2pi(float x)
{
    return x*M_2PI;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float  mmultpi2(float x)
{
    return x*M_PI_2;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE float  mmultpi4(float x)
{
    return x*M_PI_4;
}

///////////////////////////////////////////////////////////////////////////////////////
// Double Const Multiplication Functions
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double  mmultpi(double x)
{
    return x*_PI;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double  mmult2pi(double x)
{
    return x*_2PI;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double  mmultpi2(double x)
{
    return x*_PI_2;
}
///////////////////////////////////////////////////////////////////////////////////////
M_INLINE double  mmultpi4(double x)
{
    return x*_PI_4;
}

#endif //__MATHFUNC_INL__